% dlg_rej_eyeepoched - pops dialogue, called by pop_rej_eyeepoched
%                see >> help pop_rej_eyeepoched
%
% Copyright (C) 2009-2018 Olaf Dimigen & Ulrich Reinacher, HU Berlin
% olaf.dimigen@hu-berlin.de 

% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, 51 Franklin Street, Boston, MA 02110-1301, USA

function [chns minvals maxvals] = dlg_rej_eyeepochs(callingFcn,EEG)

geometry(1:8) = {1 1 1 [0.5 0.4 0.2 0.4 0.4] [0.5 0.4 0.2 0.4 0.4] [0.5 0.4 0.2 0.4 0.4] [0.5 0.4 0.2 0.4 0.4] [0.5 0.4 0.2 0.4 0.4]};

uilist(1:28) = {...
    {'Style', 'text', 'string', 'Reject epochs with out-of-range eye track','fontweight', 'bold'},...
    {'Style', 'text', 'string', 'Note: eye blinks are usually characterized by zeros (i.e. values < 1 pixel)'},...
    {},...
    {'Style', 'text', 'string', ' '},...
    {'Style', 'text', 'string', 'ET channel index'},...
    {'Style', 'text', 'string', ''},...
    {'Style', 'text', 'string', 'Reject values <'},...
    {'Style', 'text', 'string', 'Reject values >'},...
    ...
    {'Style', 'text', 'string', 'Left eye, horiz. (X).:'},...
    {'Style', 'edit', 'string', '', 'tag', 'chans_LX' }, ...
    {'Style', 'pushbutton', 'string', '...', 'enable' fastif(isempty(EEG.chanlocs), 'off', 'on') 'callback' 'tmpchanlocs = EEG.chanlocs; [tmp tmpval] = pop_chansel({tmpchanlocs.labels}, ''withindex'', ''on'', ''selectionmode'',''single''); set(findobj(gcbf, ''tag'', ''chans_LX''), ''string'',tmp); clear tmp tmpchanlocs tmpval'},...
    {'Style', 'edit', 'string', '1' },...
    {'Style', 'edit', 'string', '1024' },...
    ...
    {'Style', 'text', 'string', 'Left eye, verti. (Y):'},...
    {'Style', 'edit', 'string', '', 'tag', 'chans_LY' }, ...
    {'Style', 'pushbutton', 'string', '...', 'enable' fastif(isempty(EEG.chanlocs), 'off', 'on') 'callback' 'tmpchanlocs = EEG.chanlocs; [tmp tmpval] = pop_chansel({tmpchanlocs.labels}, ''withindex'', ''on'', ''selectionmode'',''single''); set(findobj(gcbf, ''tag'', ''chans_LY''), ''string'',tmp); clear tmp tmpchanlocs tmpval' },...
    {'Style', 'edit', 'string', '1' },...
    {'Style', 'edit', 'string', '768' },...
    ...
    {'Style', 'text', 'string', 'Right eye, horiz. (X):'},...
    {'Style', 'edit', 'string', '', 'tag', 'chans_RX' }, ...
    {'Style', 'pushbutton', 'string', '...', 'enable' fastif(isempty(EEG.chanlocs), 'off', 'on') 'callback' 'tmpchanlocs = EEG.chanlocs; [tmp tmpval] = pop_chansel({tmpchanlocs.labels}, ''withindex'', ''on'', ''selectionmode'',''single''); set(findobj(gcbf, ''tag'', ''chans_RX''), ''string'',tmp); clear tmp tmpchanlocs tmpval' },...
    {'Style', 'edit', 'string', '1' },...
    {'Style', 'edit', 'string', '1024' },...
    ...
    {'Style', 'text', 'string', 'Right eye, verti. (Y):'},...
    {'Style', 'edit', 'string', '', 'tag', 'chans_RY' }, ...
    {'Style', 'pushbutton', 'string', '...', 'enable' fastif(isempty(EEG.chanlocs), 'off', 'on') 'callback' 'tmpchanlocs = EEG.chanlocs; [tmp tmpval] = pop_chansel({tmpchanlocs.labels}, ''withindex'', ''on'', ''selectionmode'',''single''); set(findobj(gcbf, ''tag'', ''chans_RY''), ''string'',tmp); clear tmp tmpchanlocs tmpval' },...
    {'Style', 'edit', 'string', '1' },...
    {'Style', 'edit', 'string', '768' },...
    };

results = inputgui( 'geometry',geometry, ...
    'uilist',uilist,'helpcom', ['pophelp(''' callingFcn ''');'],...
    'title', ['Reject epochs based on eye tracking data -- ', callingFcn]);

if isempty(results)
    return
end

%% prepare output
chn1 = eeg_decodechan(EEG.chanlocs,results{1});
chn2 = eeg_decodechan(EEG.chanlocs,results{4});
chn3 = eeg_decodechan(EEG.chanlocs,results{7});
chn4 = eeg_decodechan(EEG.chanlocs,results{10});

min1 = str2num(results{2});
min2 = str2num(results{5});
min3 = str2num(results{8});
min4 = str2num(results{11});

max1 = str2num(results{3});
max2 = str2num(results{6});
max3 = str2num(results{9});
max4 = str2num(results{12});

chns = []; minvals = []; maxvals = [];

if ~isempty(chn1) && ~isempty(min1) && ~isempty(max1)
    chns = [chns chn1]; minvals = [minvals min1]; maxvals = [maxvals max1];
    fprintf('\nChannel %i: rejecting values < %i or > %i',chn1,min1,max1);
end
if ~isempty(chn2) && ~isempty(min2) && ~isempty(max2)
    chns = [chns chn2]; minvals = [minvals min2]; maxvals = [maxvals max2];
    fprintf('\nChannel %i: rejecting values < %i or > %i',chn2,min2,max2);
end
if ~isempty(chn3) && ~isempty(min3) && ~isempty(max3)
    chns = [chns chn3]; minvals = [minvals min3]; maxvals = [maxvals max3];
    fprintf('\nChannel %i: rejecting values < %i or > %i',chn3,min3,max3);
end
if ~isempty(chn4) && ~isempty(min4) && ~isempty(max4)
    chns = [chns chn4]; minvals = [minvals min4]; maxvals = [maxvals max4];
    fprintf('\nChannel %i: rejecting values < %i or > %i',chn4,min4,max4);
end

end